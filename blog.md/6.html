<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 简明教程 | Ravenq 的个人博客</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.4e1e9e1f.css" as="style"><link rel="preload" href="/assets/js/app.567b3485.js" as="script"><link rel="preload" href="/assets/js/32.668dffff.js" as="script"><link rel="prefetch" href="/assets/js/10.c86c1ca0.js"><link rel="prefetch" href="/assets/js/11.bcdb929e.js"><link rel="prefetch" href="/assets/js/12.966ff564.js"><link rel="prefetch" href="/assets/js/13.f65adc85.js"><link rel="prefetch" href="/assets/js/14.fc5fe175.js"><link rel="prefetch" href="/assets/js/15.a92a3e8f.js"><link rel="prefetch" href="/assets/js/16.ffb21bb3.js"><link rel="prefetch" href="/assets/js/17.011882c9.js"><link rel="prefetch" href="/assets/js/18.3daa6950.js"><link rel="prefetch" href="/assets/js/19.30d0e839.js"><link rel="prefetch" href="/assets/js/2.7fdb2499.js"><link rel="prefetch" href="/assets/js/20.f8913486.js"><link rel="prefetch" href="/assets/js/21.e172f780.js"><link rel="prefetch" href="/assets/js/22.8218cd5f.js"><link rel="prefetch" href="/assets/js/23.0d158be2.js"><link rel="prefetch" href="/assets/js/24.f07f4e44.js"><link rel="prefetch" href="/assets/js/25.de8c7777.js"><link rel="prefetch" href="/assets/js/26.0374c741.js"><link rel="prefetch" href="/assets/js/27.a2b7c06e.js"><link rel="prefetch" href="/assets/js/28.435dd0d7.js"><link rel="prefetch" href="/assets/js/29.06af7a50.js"><link rel="prefetch" href="/assets/js/3.5196bfa7.js"><link rel="prefetch" href="/assets/js/30.eb1913d5.js"><link rel="prefetch" href="/assets/js/31.f4394e88.js"><link rel="prefetch" href="/assets/js/33.e0fa4c55.js"><link rel="prefetch" href="/assets/js/34.71408e4e.js"><link rel="prefetch" href="/assets/js/35.be231ec0.js"><link rel="prefetch" href="/assets/js/36.f4ce2254.js"><link rel="prefetch" href="/assets/js/4.4b39041d.js"><link rel="prefetch" href="/assets/js/5.26404c51.js"><link rel="prefetch" href="/assets/js/6.1f1bba03.js"><link rel="prefetch" href="/assets/js/7.e3349a13.js"><link rel="prefetch" href="/assets/js/8.c62eea19.js"><link rel="prefetch" href="/assets/js/9.aed313c3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4e1e9e1f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Ravenq 的个人博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Docker 简明教程</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog.md/6.html#docker-简介" class="sidebar-link">docker 简介</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.md/6.html#docker-命令" class="sidebar-link">docker 命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.md/6.html#_1-查看容器的root用户密码" class="sidebar-link">1. 查看容器的root用户密码</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_2-查看容器日志" class="sidebar-link">2. 查看容器日志</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_3-查看正在运行的容器" class="sidebar-link">3. 查看正在运行的容器</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_4-删除容器" class="sidebar-link">4. 删除容器</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_5-停止、启动、杀死容器" class="sidebar-link">5. 停止、启动、杀死容器</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_6-查看所有镜像" class="sidebar-link">6. 查看所有镜像</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_7-删除镜像" class="sidebar-link">7. 删除镜像</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_8-镜像标签" class="sidebar-link">8. 镜像标签</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_9-运行容器" class="sidebar-link">9. 运行容器</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_10-拉取镜像" class="sidebar-link">10. 拉取镜像</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#镜像本地迁移" class="sidebar-link">镜像本地迁移</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_11-构建镜像" class="sidebar-link">11. 构建镜像</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_12-拷贝文件" class="sidebar-link">12. 拷贝文件</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_13-volume" class="sidebar-link">13. volume</a></li></ul></li><li><a href="/blog.md/6.html#dockerfile" class="sidebar-link">Dockerfile</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.md/6.html#_1-from" class="sidebar-link">1. FROM</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_2-maintainer" class="sidebar-link">2.MAINTAINER</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_3-run" class="sidebar-link">3. RUN</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_4-user" class="sidebar-link">4. USER</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_5-expose" class="sidebar-link">5. EXPOSE</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_6-env" class="sidebar-link">6. ENV</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_7-add" class="sidebar-link">7. ADD</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_8-workdir" class="sidebar-link">8. WORKDIR</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_9-cmd" class="sidebar-link">9. CMD</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_10-entrypoint" class="sidebar-link">10. ENTRYPOINT</a></li><li class="sidebar-sub-header"><a href="/blog.md/6.html#_11-voloume" class="sidebar-link">11. VOLOUME</a></li></ul></li><li><a href="/blog.md/6.html#后记" class="sidebar-link">后记</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="docker-简明教程"><a href="#docker-简明教程" aria-hidden="true" class="header-anchor">#</a> Docker 简明教程</h1> <h2 id="docker-简介"><a href="#docker-简介" aria-hidden="true" class="header-anchor">#</a> docker 简介</h2> <p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架包括系统。</p> <h2 id="docker-命令"><a href="#docker-命令" aria-hidden="true" class="header-anchor">#</a> docker 命令</h2> <h3 id="_1-查看容器的root用户密码"><a href="#_1-查看容器的root用户密码" aria-hidden="true" class="header-anchor">#</a> 1. 查看容器的root用户密码</h3> <p>docker 登录账户密码是随机生成的，可以通过以下命令查看密码：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker logs &lt;container name or ID&gt; 2&gt;&amp;1 | grep '^User: ' | tail -n1
</code></pre></div><h3 id="_2-查看容器日志"><a href="#_2-查看容器日志" aria-hidden="true" class="header-anchor">#</a> 2. 查看容器日志</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker logs -f &lt;container name or ID&gt;
</code></pre></div><h3 id="_3-查看正在运行的容器"><a href="#_3-查看正在运行的容器" aria-hidden="true" class="header-anchor">#</a> 3. 查看正在运行的容器</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker ps [-a]
</code></pre></div><p>-a 为可选项：查看所有容器，包括已经停止的容器。</p> <h3 id="_4-删除容器"><a href="#_4-删除容器" aria-hidden="true" class="header-anchor">#</a> 4. 删除容器</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker rm &lt;container name or ID&gt;
</code></pre></div><p>想清楚所有容器，可以使用命名组合：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker rm $(docker ps -a -q)
</code></pre></div><p>其中 -q 为只列出容器 id。</p> <h3 id="_5-停止、启动、杀死容器"><a href="#_5-停止、启动、杀死容器" aria-hidden="true" class="header-anchor">#</a> 5. 停止、启动、杀死容器</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker stop &lt;container name or ID&gt;
docker start &lt;container name or ID&gt;
docker kill &lt;container name or ID&gt;
</code></pre></div><h3 id="_6-查看所有镜像"><a href="#_6-查看所有镜像" aria-hidden="true" class="header-anchor">#</a> 6. 查看所有镜像</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker images
</code></pre></div><h3 id="_7-删除镜像"><a href="#_7-删除镜像" aria-hidden="true" class="header-anchor">#</a> 7. 删除镜像</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker rmi &lt;image id&gt;

docker rmi $(docker images -q) // 删除所有镜像

docker rmi $(docker images -q -f dangling=true) // 删除所有没有标签的镜像
</code></pre></div><h3 id="_8-镜像标签"><a href="#_8-镜像标签" aria-hidden="true" class="header-anchor">#</a> 8. 镜像标签</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker tag &lt;image id&gt; &lt;tag name&gt;
</code></pre></div><p>如果一个镜像 id 对应着连个不同的镜像名称可以使用 rmi 命令来删除多余的 tag:</p> <div class="language-sh extra-class"><pre class="language-text"><code>aqcoder@ubuntu:~$ sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
zggj                latest              327b06d562de        21 hours ago        1.096 GB
zggj2               latest              327b06d562de        21 hours ago        1.096 GB
aqcoder@ubuntu:~$ sudo docker rmi zggj2
Untagged: zggj2:latest
aqcoder@ubuntu:~$ sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
zggj                latest              327b06d562de        21 hours ago        1.096 GB
</code></pre></div><h3 id="_9-运行容器"><a href="#_9-运行容器" aria-hidden="true" class="header-anchor">#</a> 9. 运行容器</h3> <p>运行容器的参数比较多，详见 help。这里列出常见的命令。</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run --name test -it 80:80 -p 22:22 -d zggj /bin/bash
docker run --name test -p 80:80 -p 22:22 -d zggj
</code></pre></div><p>第一种为连接容器的 STDIN 相当于进入了容器的 bash。</p> <p>-- name 选项为设置容器的名称。</p> <p>-i 保存容器的标准输入 STDIN。</p> <p>-t 分配一个伪终端。</p> <p>-d 分离。</p> <p>-p 端口映射，前面为本机端口，后面为容器端口。</p> <h3 id="_10-拉取镜像"><a href="#_10-拉取镜像" aria-hidden="true" class="header-anchor">#</a> 10. 拉取镜像</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker pull &lt;镜像名:tag&gt;
</code></pre></div><h3 id="镜像本地迁移"><a href="#镜像本地迁移" aria-hidden="true" class="header-anchor">#</a> 镜像本地迁移</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker save &lt;image id&gt; &gt; /path/to/save.tar // 保存镜像到本地
docker load &lt; /path/to/save.tar // 加载镜像
</code></pre></div><div class="language-sh extra-class"><pre class="language-text"><code>docker export -o /path/to/save.tar &lt;container id&gt;
docker import /path/to/save.tar
</code></pre></div><p>save 保存的是镜像，包括镜像的历史。
export 导出的只是荣建快照，不包含镜像历史等，相对较小。</p> <h3 id="_11-构建镜像"><a href="#_11-构建镜像" aria-hidden="true" class="header-anchor">#</a> 11. 构建镜像</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker build -t &lt;image name&gt; /path/to/Dockerfile
</code></pre></div><h3 id="_12-拷贝文件"><a href="#_12-拷贝文件" aria-hidden="true" class="header-anchor">#</a> 12. 拷贝文件</h3> <div class="language-sh extra-class"><pre class="language-text"><code>docker cp &lt;container id&gt;:/path/to/file /path/to/save  // 从容器中考出
docker cp /path/to/file &lt;conttainer id&gt;:/path/to/save // 考至容器
</code></pre></div><h3 id="_13-volume"><a href="#_13-volume" aria-hidden="true" class="header-anchor">#</a> 13. volume</h3> <p>为了达到数据可持久性存储、备份、共享，docker 提出了 volume 数据卷的概念。你可以把 volume 理解为一个指定的特殊的数据存储区，由于他绕过了镜像的 Union File System，所以如下命令对 volume 中的数据是无效的：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker save
docker export
docker commit
</code></pre></div><h4 id="a-创建-volume"><a href="#a-创建-volume" aria-hidden="true" class="header-anchor">#</a> a. 创建 volume</h4> <p>创建 volume 有两种方式：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run -v /path/in/container/ &lt;image id&gt;
docker run -v /path/to/host:/path/to/container &lt;image id&gt; # 挂载方式
</code></pre></div><p>第一种方式会创建一个数据卷，并挂载数据卷到指定的容器中的目录。所有容器对此目录的数据操作都会复制到数据卷中。</p> <p>第二种方式会挂载宿主主机的目录到容器中的目录，此时宿主主机的目录就相当于是数据卷。</p> <p>你可以使用 docker cp 命令来拷贝数据卷中的数据：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker cp &lt;container id&gt;:/path/to/volume /path/to/host
</code></pre></div><h4 id="b-数据共享"><a href="#b-数据共享" aria-hidden="true" class="header-anchor">#</a> b. 数据共享</h4> <p>容器之间的数据卷可以共享：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker run --name container1 -v /data image1
docker run --name container2 --volumes-from container1 image2
</code></pre></div><h4 id="c-数据卷管理"><a href="#c-数据卷管理" aria-hidden="true" class="header-anchor">#</a> c. 数据卷管理</h4> <p>数据卷是独立于 docker 的 union file system 的，使用 -v 选项可以删除数据卷：</p> <div class="language-sh extra-class"><pre class="language-text"><code>docker rm -v &lt;container id&gt;
</code></pre></div><p>关于数据卷的更多内容可以参考: <a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="noopener noreferrer">http://www.tuicool.com/articles/uYzeAnz<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="dockerfile"><a href="#dockerfile" aria-hidden="true" class="header-anchor">#</a> Dockerfile</h2> <p>Dockerfile是一个镜像的表示，可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器</p> <p>所有的 Dockerfile 命令格式都是:</p> <div class="language-sh extra-class"><pre class="language-text"><code># this is comment
INSTRUCTION arguments
</code></pre></div><p>Dockerfile 的注释使用 # 开头。
虽然指令忽略大小写，但是建议使用大写。</p> <p>下面列出常用命令和用法：</p> <h3 id="_1-from"><a href="#_1-from" aria-hidden="true" class="header-anchor">#</a> 1. FROM</h3> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>FROM &lt;image&gt;[:&lt;tag&gt;]
</code></pre></div><p>指定构建的镜像使用的基础镜像。</p> <h3 id="_2-maintainer"><a href="#_2-maintainer" aria-hidden="true" class="header-anchor">#</a> 2.MAINTAINER</h3> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>MAINTAINER &lt;name&gt;
</code></pre></div><p>指明镜像的维护者。</p> <h3 id="_3-run"><a href="#_3-run" aria-hidden="true" class="header-anchor">#</a> 3. RUN</h3> <p>RUN 命令在构建的时候执行命令。相当于在镜像内执行命令。</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>RUN &lt;command&gt;
</code></pre></div><p>或:</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ]
</code></pre></div><h3 id="_4-user"><a href="#_4-user" aria-hidden="true" class="header-anchor">#</a> 4. USER</h3> <p>指定镜像内的用户，可以多次指定，对其后的命令生效，最后一个会作为容器启动时进入的用户。</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>USER &lt;user name&gt;
</code></pre></div><h3 id="_5-expose"><a href="#_5-expose" aria-hidden="true" class="header-anchor">#</a> 5. EXPOSE</h3> <p>EXPOSE 命令可以开发容器的端口</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]

</code></pre></div><h3 id="_6-env"><a href="#_6-env" aria-hidden="true" class="header-anchor">#</a> 6. ENV</h3> <p>用于设置运行容器的环境变量</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>ENV &lt;key&gt; &lt;value&gt;
</code></pre></div><h3 id="_7-add"><a href="#_7-add" aria-hidden="true" class="header-anchor">#</a> 7. ADD</h3> <p>从主机复制文件到镜像</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>ADD &lt;src&gt; &lt;dest&gt;
</code></pre></div><h3 id="_8-workdir"><a href="#_8-workdir" aria-hidden="true" class="header-anchor">#</a> 8. WORKDIR</h3> <p>配置 RUN, CMD, ENTRYPOINT 命令设置当前工作路径</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>WORKDIR /path/to/workdir
</code></pre></div><h3 id="_9-cmd"><a href="#_9-cmd" aria-hidden="true" class="header-anchor">#</a> 9. CMD</h3> <p>CMD 命令为启动容器时需要执行的命令，如果在 RUN 命令的参数中指定了命令参数则会覆盖此命令。
一个 Dockerfile 里只能有一个 CMD，如果有多个，只有最后一个生效。</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
CMD [&quot;param1&quot;,&quot;param2&quot;] // 作为 ENTRYPOINT 的默认参数
CMD command param1 param2
</code></pre></div><h3 id="_10-entrypoint"><a href="#_10-entrypoint" aria-hidden="true" class="header-anchor">#</a> 10. ENTRYPOINT</h3> <p>设置容器的进入点。</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>ENTRYPOINT cmd param1 param2 ...
</code></pre></div><p>或</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;cmd&quot;, &quot;param1&quot;, &quot;param2&quot;...]

</code></pre></div><h3 id="_11-voloume"><a href="#_11-voloume" aria-hidden="true" class="header-anchor">#</a> 11. VOLOUME</h3> <p>创建数据卷</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>VOLOUME /data
</code></pre></div><p>注意：不要把 ENTRYPOINT 和 CMD 命令搞混，你可以吧 ENTRYPOINT 理解为把容器变成了一个执行程序，启动容器是就相当于执行了 ENTRYPOINT 指定的命令这个“程序”。同时 CMD 命令可以给他提供默认参数，当然也可以不提供。</p> <h2 id="后记"><a href="#后记" aria-hidden="true" class="header-anchor">#</a> 后记</h2> <p>这些就是 docker 的基础使用教程。列举的都是命令，可以当手册、笔记用。
记下来我会把我迁移本博客到 docker 的整个过程记录下来，当做本文的一个实战。如果你对这些命令摸不着头脑的话不放看看我的实例。</p> <p>&lt;实例没写完，后期不上地址&gt;</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.567b3485.js" defer></script><script src="/assets/js/32.668dffff.js" defer></script>
  </body>
</html>
